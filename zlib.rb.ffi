module Zlib

  @@@
  constants do |c|
    c.include 'zlib.h'
    c.include 'zconf.h'

    c.const 'ZLIB_VERSION', '%s', '(char *)', nil, to_s

    c.const 'Z_NO_FLUSH',            nil, nil, 'NO_FLUSH'
    c.const 'Z_PARTIAL_FLUSH',       nil, nil, 'PARTIAL_FLUSH'
    c.const 'Z_SYNC_FLUSH',          nil, nil, 'SYNC_FLUSH'
    c.const 'Z_FULL_FLUSH',          nil, nil, 'FULL_FLUSH'
    c.const 'Z_FINISH',              nil, nil, 'FINISH'
    c.const 'Z_BLOCK',               nil, nil, 'BLOCK'

    c.const 'Z_OK',                  nil, nil, 'OK'
    c.const 'Z_STREAM_END',          nil, nil, 'STREAM_END'
    c.const 'Z_NEED_DICT',           nil, nil, 'NEED_DICT'
    c.const 'Z_ERRNO',               nil, nil, 'ERRNO'
    c.const 'Z_STREAM_ERROR',        nil, nil, 'STREAM_ERROR'
    c.const 'Z_DATA_ERROR',          nil, nil, 'DATA_ERROR'
    c.const 'Z_MEM_ERROR',           nil, nil, 'MEM_ERROR'
    c.const 'Z_BUF_ERROR',           nil, nil, 'BUF_ERROR'
    c.const 'Z_VERSION_ERROR',       nil, nil, 'VERSION_ERROR'

    c.const 'Z_NO_COMPRESSION',      nil, nil, 'NO_COMPRESSION'
    c.const 'Z_BEST_SPEED',          nil, nil, 'BEST_SPEED'
    c.const 'Z_BEST_COMPRESSION',    nil, nil, 'BEST_COMPRESSION'
    c.const 'Z_DEFAULT_COMPRESSION', nil, nil, 'DEFAULT_COMPRESSION'

    c.const 'Z_FILTERED',            nil, nil, 'FILTERED'
    c.const 'Z_HUFFMAN_ONLY',        nil, nil, 'HUFFMAN_ONLY'
    c.const 'Z_RLE',                 nil, nil, 'RLE'
    c.const 'Z_FIXED',               nil, nil, 'FIXED'
    c.const 'Z_DEFAULT_STRATEGY',    nil, nil, 'DEFAULT_STRATEGY'

    c.const 'Z_DEFLATED',            nil, nil, 'DEFLATED'

    c.const 'Z_MAX_WBITS',           nil, nil, 'MAX_WBITS'
    c.const 'Z_MAX_MEM_LEVEL',       nil, nil, 'MAX_MEM_LEVEL'
    c.const 'Z_DEF_MEM_LEVEL',       nil, nil, 'DEF_MEM_LEVEL'
  end
  @@@

  class Error < StandardError; end

  class StreamEnd < Error; end
  class NeedDict < Error; end
  class StreamError < Error; end
  class DataError < Error; end
  class BufError < Error; end
  class VersionError < Error; end
  class MemError < Error; end

  class ZStream < FFI::Struct

    @@@
    struct do |s|
      s.include "zlib.h"

      s.name "struct z_stream_s"
      s.field :next_in,   :pointer
      s.field :avail_in,  :uint
      s.field :total_in,  :ulong

      s.field :next_out,  :pointer
      s.field :avail_out, :uint
      s.field :total_out, :ulong

      s.field :msg,       :string
      s.field :state,     :pointer

      s.field :zalloc,    :pointer
      s.field :zfree,     :pointer
      s.field :opaque,    :pointer

      s.field :data_type, :int
      s.field :adler,     :ulong
      s.field :reserved,  :ulong
    end
    @@@

    #--
    # HACK from MRI's zlib.c
    #++

    READY = 0x1
    IN_STREAM = 0x2
    FINISHED = 0x4
    CLOSING = 0x8
    UNUSED = 0x10

    attr_accessor :flags

    def self.inherited(subclass)
      subclass.instance_variable_set :@layout, @layout
      subclass.instance_variable_set :@size, @size
    end

    def initialize
      super

      self[:avail_in] = 0
      self[:avail_out] = 0
      self[:next_in] = nil
      self[:opaque] = nil
      self[:zalloc] = nil
      self[:zfree] = nil

      reset_input
      @output = nil
      @flags = 0
      @func = nil
    end

    def detatch_output
      if @output.nil? then
        data = ''
      else
        data = @output

        @output = nil
        self[:avail_out] = 0
        self[:next_out] = nil
      end

      data
    end

    def end
      unless ready? then
        warn "attempt to close uninitialized stream; ignored."
        return nil
      end

      if in_stream? then
        warn "attempt to close unfinished zstream; reset forced"
        reset
      end

      reset_input

      err = Zlib.send @func_end, pointer

      unless err == Zlib::OK then
        msg = self[:msg].read_string unless self[:msg].nil?
        Zlib.raise_error err, msg
      end

      @flags = 0

      # HACK this may be wrong
      @output = nil
      @next_out.free unless @next_out.nil?
      @next_out = nil

      nil
    end

    alias :close :end

    def expand_output
      if @output.nil? then
        @output = ''
        @next_out = MemoryPointer.new CHUNK if @next_out.nil?
        @next_out.write_string "\000" * CHUNK
        self[:next_out] = @next_out
      else
        have = CHUNK - self[:avail_out]
        @output << @next_out.read_string(have)

        self[:next_out] = @next_out # Zlib advances self[:next_out]
      end

      self[:avail_out] = CHUNK
    end

    def finish
      run '', Zlib::FINISH

      detatch_output
    end

    def finished?
      (@flags & FINISHED) == FINISHED
    end

    def in_stream?
      (@flags & IN_STREAM) == IN_STREAM
    end

    def input_empty?
      @input.nil? or @input.empty?
    end

    def ready
      @flags |= READY
    end

    def ready?
      (@flags & READY) == READY
    end

    def reset
      err = Zlib.send @func_reset, pointer

      unless err == Zlib::OK then
        msg = self[:msg].read_string unless self[:msg].nil?
        Zlib.raise_error err, msg
      end

      @flags = READY

      reset_input
    end

    def reset_input
      @input = nil
    end

    def run(data, flush)
      if @input.nil? and data.empty? then
        data_in = MemoryPointer.new 1
        data_in.write_string "\000", 1
        self[:next_in] = data_in
        self[:avail_in] = 0
      else
        @input ||= ''
        @input << data

        data_in = MemoryPointer.new @input.length
        data_in.write_string @input, @input.length
        self[:next_in] = data_in
        self[:avail_in] = @input.length
      end

      expand_output if self[:avail_out] == 0

      loop do
        err = Zlib.send @func_run, pointer, flush

        available = self[:avail_out]

        expand_output # HACK does this work when err is set?

        if err == Zlib::STREAM_END then
          @flags &= ~IN_STREAM
          @flags |= FINISHED
          break
        end

        unless err == Zlib::OK then
          if flush != Zlib::FINISH and err == Zlib::BUF_ERROR and
             self[:avail_out] > 0 then
            @flags |= IN_STREAM
            break
          end

          if self[:avail_in] > 0 then
            @input = self[:next_in].read_string(self[:avail_in]) + @input
          end

          msg = self[:msg].read_string unless self[:msg].nil?
          Zlib.raise_error err, msg
        end

        if available > 0 then
          @flags |= IN_STREAM
          break
        end
      end

      reset_input

      if self[:avail_in] > 0 then
        @input = self[:next_in].read_string self[:avail_in]
      end
    ensure
      data_in.free
      self[:next_in] = nil
    end

  end

  set_ffi_lib 'libz'

  # deflateInit2 is a macro pointing to deflateInit2_
  attach_function 'deflateInit2_', :deflateInit2_, [
                    :pointer, # z_streamp strm
                    :int,     # int level
                    :int,     # int method
                    :int,     # int windowBits
                    :int,     # int memLevel
                    :int,     # int strategy
                    :string,  # ZLIB_VERSION
                    :int      # (int)sizeof(z_stream)
                  ], :int

  def self.deflateInit2(stream, level, method, window_bits, mem_level, strategy)
    deflateInit2_ stream, level, method, window_bits, mem_level, strategy,
                  ZLIB_VERSION, ZStream.size
  end

  attach_function 'deflate',        :deflate,         [:pointer, :int], :int
  attach_function 'deflateEnd',     :deflateEnd,      [:pointer],       :int
  attach_function 'deflateReset',   :deflateReset,    [:pointer],       :int

  # inflateInit2 is a macro pointing to inflateInit2_
  attach_function 'inflateInit2_', :inflateInit2_,
                  [:pointer, :int, :string, :int], :int

  def self.inflateInit2(stream, window_bits)
    inflateInit2_ stream, window_bits, ZLIB_VERSION, ZStream.size
  end

  attach_function 'inflate',        :inflate,         [:pointer, :int], :int
  attach_function 'inflateEnd',     :inflateEnd,      [:pointer],       :int
  attach_function 'inflateReset',   :inflateReset,    [:pointer],       :int

  attach_function 'adler32',        :adler32_c,       [:ulong, :string, :uint],
                  :ulong
  attach_function 'crc32',          :crc32_c,         [:ulong, :string, :uint],
                  :ulong
  attach_function 'get_crc_table',  :get_crc_table_c, [], :pointer

  attach_function 'zError', :zError, [:int], :string

  # Chunk size for inflation and deflation

  CHUNK = 1024

  #--
  # HACK from zlib.c
  #++

  GZ_EXTRAFLAG_FAST = 0x4
  GZ_EXTRAFLAG_SLOW = 0x2

  class Deflate < ZStream

    def self.deflate(data, level = Zlib::DEFAULT_COMPRESSION)
      deflator = new level

      zipped = deflator.deflate data, Zlib::FINISH

      zipped
    ensure
      deflator.end
    end

    def initialize(level = Zlib::DEFAULT_COMPRESSION,
                   window_bits = Zlib::MAX_WBITS,
                   mem_level = Zlib::DEF_MEM_LEVEL,
                   strategy = Zlib::DEFAULT_STRATEGY)
      level ||= Zlib::DEFAULT_COMPRESSION
      window_bits ||= Zlib::MAX_WBITS
      mem_level ||= Zlib::DEF_MEM_LEVEL
      strategy ||= Zlib::DEFAULT_STRATEGY

      super()

      @func_end = :deflateEnd
      @func_reset = :deflateReset
      @func_run = :deflate

      err = Zlib.deflateInit2(pointer, level, Zlib::DEFLATED,
                              window_bits, mem_level, strategy)

      Zlib.raise_error unless err == Zlib::OK

      ready
    end

    def deflate(data, flush = Zlib::NO_FLUSH)
      if data.nil? then
        run '', Zlib::FINISH
        return
      end

      data = Type.coerce_to data, String, :to_str

      if flush != Zlib::NO_FLUSH or not data.empty? then
        run data, flush
      end

      zipped = detatch_output
    end

    def finish
      run '', Zlib::FINISH

      detatch_output
    end

  end

  class GzipFile
    class Error < Zlib::Error; end

    def self.wrap(*args)
      obj = new(*args)

      if block_given? then
        begin
          yield obj
        ensure
          obj.close
        end
      end
    end

  end

  class GzipReader < GzipFile # HACK usa a buffer class

    def initialize(io)
      @io = io
      window_bits = Zlib::MAX_WBITS + 16 # gzip header

      @zstream = Zlib::Inflate.new window_bits

      @buffer = ''
    end

    def close
    end

    def eof?
      @zstream.finished? and @zstream.input_empty?
    end

    def finish
      true
    end

    def pos
      @zstream[:total_out] - @buffer.length
    end

    def read(length = nil)
      data = @buffer

      while chunk = @io.read(CHUNK) do
        data << @zstream.inflate(chunk)
        break if length and data.length > length
      end

      if length then
        @buffer = data.slice! length..-1
      else
        @buffer = ''
      end

      data
    rescue Zlib::Error => e
      raise GzipFile::Error, e.message
    end

  end

  class GzipWriter < GzipFile # HACK use a buffer class

    def initialize(io, level = Zlib::DEFAULT_COMPRESSION,
                   strategy = Zlib::DEFAULT_STRATEGY)
      @io = io
      window_bits = Zlib::MAX_WBITS + 16 # gzip header

      @zstream = Zlib::Deflate.new level, window_bits, nil, strategy

      @buffer = ''
    end

    def close
      finish
      @io.close if @io.respond_to? :close
      nil
    end

    def finish
      @io.write @zstream.deflate(@buffer, Zlib::FINISH)
    rescue Zlib::Error => e
      raise GzipFile::Error, e.message
    end

    def flush
      true
    end

    def write(data)
      @buffer << data
      data.length
    end

  end

  class Inflate < ZStream

    def self.inflate(data)
      inflator = new

      unzipped = inflator.inflate data

      unzipped
    ensure
      inflator.end
    end

    def initialize(window_bits = Zlib::MAX_WBITS)
      super()

      @func_end = :inflateEnd
      @func_reset = :inflateReset
      @func_run = :inflate

      err = Zlib.inflateInit2 pointer, window_bits

      Zlib.raise_error err unless err == Zlib::OK # HACK

      ready
    end

    def inflate(data)
      data = Type.coerce_to data, String, :to_str unless data.nil?

      if finished? then
        if data.nil? then
          unzipped = detatch_output
        else
          @input ||= ''
          @input << data

          unzipped = ''
        end
      else
        if data.nil? then
          run '', Zlib::FINISH
        elsif not data.empty? then
          run data, Zlib::SYNC_FLUSH
        end

        unzipped = detatch_output

        if finished? and not @input.nil? then
          expand_output
        end
      end

      unzipped
    end

  end

  def self.adler32(string = "", sum = 1)
    do_checksum(string, sum, :adler32_c)
  end

  def self.crc_table
    get_crc_table_c.read_array_of_long(256).map do |x|
      x >= 0 ? x : 2 ** 32 + x # HACK convert back to unsigned
    end
  end

  def self.crc32(string = "", sum = 0)
    do_checksum(string, sum, :crc32_c)
  end

  def self.do_checksum(string, vsum, type)
    if vsum
      raise RangeError if vsum >= (2 ** 128)
      raise "Explain why you did this: email ephoenix@engineyard.com" if vsum < 0
      sum = vsum
    elsif string.nil?
      sum = 0
    else
      sum = send(type, 0, nil, 0)
    end

    send(type, sum, string, string ? string.size : 0)
  end

  def self.raise_error(error, message = nil)
    message = zError error if message.nil?

    klass = case error
            when Zlib::STREAM_END   then Zlib::StreamEnd
            when Zlib::NEED_DICT    then Zlib::NeedDict
            when Zlib::STREAM_ERROR then Zlib::StreamError
            when Zlib::DATA_ERROR   then Zlib::DataError
            when Zlib::BUF_ERROR    then Zlib::BufError
            when Zlib::MEM_ERROR    then Zlib::MemError
            when Errno then Errno.handle message
            else
              message = "unknown zlib error #{error}: #{message}"
              Zlib::Error
            end

    raise klass, message
  end

end

