require 'ext/zlib/zlib'

module Zlib

  class Error < StandardError; end

  class Stream < FFI::Struct
    @@@
    name "struct z_stream_s"
    include "zlib.h"
    field :next_in, :pointer
    field :avail_in, :uint
    field :total_in, :ulong
    field :next_out, :pointer
    field :avail_out, :uint
    field :total_out, :ulong
    field :msg, :string
    @@@
  end

  attach_function 'rbx_Zlib_z_stream_Alloc', :z_stream_Alloc, [], :pointer

  attach_function 'rbx_Zlib_deflateInit2', :deflateInit2, [
                    :pointer, # z_streamp strm
                    :int,     # int level
                    :int,     # int method
                    :int,     # int windowBits
                    :int,     # int memLeel
                    :int,     # int strategy
                  ], :int

  attach_function 'deflate',    :deflate,    [:pointer, :int], :int
  attach_function 'deflateEnd', :deflateEnd, [:pointer],       :int

  attach_function 'rbx_Zlib_inflateInit2', :inflateInit2, [:pointer, :int], :int

  attach_function 'inflate',     :inflate,     [:pointer, :int], :int
  attach_function 'inflateEnd',  :inflateEnd,  [:pointer],       :int

  #--
  # From zlib.h
  #++

  NO_FLUSH = 0
  PARTIAL_FLUSH = 1
  SYNC_FLUSH = 2
  FULL_FLUSH = 3
  FINISH = 4
  BLOCK = 5

  OK = 0
  STREAM_END = 1
  NEED_DICT = 2
  ERRNO = -1
  STREAM_ERROR = -2
  DATA_ERROR = -3
  MEM_ERROR = -4
  BUF_ERROR = -5
  VERSION_ERROR = -6

  NO_COMPRESSION = 0
  BEST_SPEED = 1
  BEST_COMPRESSION = 9
  DEFAULT_COMPRESSION = -1

  FILTERED = 1
  HUFFMAN_ONLY = 2
  RLE = 3
  FIXED = 4
  DEFAULT_STRATEGY = 0

  DEFLATED = 8

  #--
  # HACK from zconf.h
  #++

  MAX_WBITS = 15
  MAX_MEM_LEVEL = 9
  DEF_MEM_LEVEL = 9

  #--
  # HACK from zlib.c
  #--

  GZ_EXTRAFLAG_FAST = 0x4
  GZ_EXTRAFLAG_SLOW = 0x2

  class Deflate
    def self.deflate(data)
      Compression::ZLib.new.deflate data
    end
  end

  class GzipFile
    class Error < Zlib::Error; end
  end

  class GzipReader # HACK usa a buffer class

    CHUNK = 1024

    def initialize(io)
      @stream_p = Zlib.z_stream_Alloc
      @stream = Zlib::Stream.new @stream_p

      @window_bits = Zlib::MAX_WBITS + 16 # gzip header
      err = Zlib.inflateInit2 @stream_p, @window_bits

      raise GzipFile::Error, "Zlib error #{err}" unless err == Zlib::OK # HACK

      @io = io

      @buffer = ''
    end

    def close
    end

    def finish
      true
    end

    def read
      err = nil
      data_in = MemoryPointer.new CHUNK
      data_out = MemoryPointer.new CHUNK

      begin
        chunk_in = @io.read CHUNK

        break if chunk_in.length == 0

        data_in.write_string chunk_in, chunk_in.length

        @stream[:avail_in] = chunk_in.length
        @stream[:next_in] = data_in

        begin
          @stream[:avail_out] = CHUNK
          @stream[:next_out] = data_out

          err = Zlib.inflate @stream_p, Zlib::NO_FLUSH

          case err
          when Zlib::STREAM_ERROR then
            raise GzipFile::Error, "Zlib stream error"
          when Zlib::NEED_DICT then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib data error, need dictionary"
          when Zlib::DATA_ERROR then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib data error: #{@stream[:msg]}"
          when Zlib::MEM_ERROR then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib memory error"
          end

          have = CHUNK - @stream[:avail_out]

          chunk_out = data_out.read_string have

          @buffer << chunk_out
        end while @stream[:avail_out] == 0

      end until err == Zlib::STREAM_END

      Zlib.inflateEnd @stream_p

      raise GzipFile::Error, "Zlib data error" if err == Zlib::DATA_ERROR

      return @buffer
    ensure
      data_in.free
      data_out.free
    end

  end

  class GzipWriter # HACK use a buffer class

    CHUNK = 1024

    def initialize(io, level = Zlib::DEFAULT_COMPRESSION,
                   strategy = Zlib::DEFAULT_STRATEGY)
      @stream_p = Zlib.z_stream_Alloc
      @stream = Zlib::Stream.new @stream_p

      @level = level
      @method = Zlib::DEFLATED
      @window_bits = Zlib::MAX_WBITS + 16 # gzip header
      @mem_level = Zlib::DEF_MEM_LEVEL
      @strategy = strategy

      err = Zlib.deflateInit2(@stream_p, @level, @method, @window_bits,
                              @mem_level, @strategy)

      raise GzipFile::Error, "Zlib error #{err}" unless err == Zlib::OK # HACK

      @io = io

      @buffer = ''
    end

    def close
      finish
      @io.close
      nil
    end

    def finish
      flush = Zlib::NO_FLUSH

      while flush != Zlib::FINISH do
        chunk_in = @buffer.slice! 0, CHUNK
        flush = Zlib::FINISH if @buffer.empty?

        data_in = MemoryPointer.new chunk_in.length
        data_in.write_string chunk_in, chunk_in.length

        @stream[:next_in] = data_in
        @stream[:avail_in] = chunk_in.length

        begin
          data_out = MemoryPointer.new CHUNK

          @stream[:avail_out] = CHUNK
          @stream[:next_out] = data_out

          err = Zlib.deflate @stream_p, flush

          raise GzipFile::Error, "Zlib stream error" if err == Zlib::STREAM_ERROR

          have = CHUNK - @stream[:avail_out]

          chunk_out = data_out.read_string have

          @io.write chunk_out
        end while @stream[:avail_out] == 0
      end

      Zlib.deflateEnd @stream_p

      @io
    end

    def flush
      true
    end

    def write(data)
      @buffer << data
      data.length
    end

  end

  class Inflate
    def self.inflate(data)
      Compression::ZLib.new.inflate data
    end
  end

end

