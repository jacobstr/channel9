require 'ext/zlib/zlib'

module Zlib

  class Error < StandardError; end

  class Stream < FFI::Struct
    @@@
    name "struct z_stream_s"
    include "zlib.h"
    field :next_in, :pointer
    field :avail_in, :uint
    field :total_in, :ulong
    field :next_out, :pointer
    field :avail_out, :uint
    field :total_out, :ulong
    field :msg, :string
    @@@
  end

  attach_function 'rbx_Zlib_z_stream_Alloc', :z_stream_Alloc, [], :pointer

  attach_function 'rbx_Zlib_deflateInit2', :deflateInit2, [
                    :pointer, # z_streamp strm
                    :int,     # int level
                    :int,     # int method
                    :int,     # int windowBits
                    :int,     # int memLeel
                    :int,     # int strategy
                  ], :int

  attach_function 'deflate',    :deflate,    [:pointer, :int], :int
  attach_function 'deflateEnd', :deflateEnd, [:pointer],       :int

  attach_function 'rbx_Zlib_inflateInit2', :inflateInit2, [:pointer, :int], :int

  attach_function 'inflate',     :inflate,     [:pointer, :int], :int
  attach_function 'inflateEnd',  :inflateEnd,  [:pointer],       :int

  # Chunk size for inflation and deflation

  CHUNK = 1024

  #--
  # From zlib.h
  #++

  NO_FLUSH = 0
  PARTIAL_FLUSH = 1
  SYNC_FLUSH = 2
  FULL_FLUSH = 3
  FINISH = 4
  BLOCK = 5

  OK = 0
  STREAM_END = 1
  NEED_DICT = 2
  ERRNO = -1
  STREAM_ERROR = -2
  DATA_ERROR = -3
  MEM_ERROR = -4
  BUF_ERROR = -5
  VERSION_ERROR = -6

  NO_COMPRESSION = 0
  BEST_SPEED = 1
  BEST_COMPRESSION = 9
  DEFAULT_COMPRESSION = -1

  FILTERED = 1
  HUFFMAN_ONLY = 2
  RLE = 3
  FIXED = 4
  DEFAULT_STRATEGY = 0

  DEFLATED = 8

  #--
  # HACK from zconf.h
  #++

  MAX_WBITS = 15
  MAX_MEM_LEVEL = 9
  DEF_MEM_LEVEL = 9

  #--
  # HACK from zlib.c
  #--

  GZ_EXTRAFLAG_FAST = 0x4
  GZ_EXTRAFLAG_SLOW = 0x2

  class Deflate

    def self.deflate(data)
      new.deflate data
    end

    def initialize(level = Zlib::DEFAULT_COMPRESSION,
                   window_bits = Zlib::MAX_WBITS,
                   mem_level = Zlib::DEF_MEM_LEVEL,
                   strategy = Zlib::DEFAULT_STRATEGY)
      level ||= Zlib::DEFAULT_COMPRESSION
      window_bits ||= Zlib::MAX_WBITS
      mem_level ||= Zlib::DEF_MEM_LEVEL
      strategy ||= Zlib::DEFAULT_STRATEGY

      @stream_p = Zlib.z_stream_Alloc
      @stream = Zlib::Stream.new @stream_p

      err = Zlib.deflateInit2(@stream_p, level, Zlib::DEFLATED, window_bits,
                              mem_level, strategy)

      raise GzipFile::Error, "Zlib error #{err}" unless err == Zlib::OK # HACK
    end

    def deflate(data)
      flush = Zlib::NO_FLUSH

      data = data.dup
      buffer = ''

      while flush != Zlib::FINISH do
        chunk_in = data.slice! 0, CHUNK
        flush = Zlib::FINISH if data.empty?

        data_in = MemoryPointer.new chunk_in.length
        data_in.write_string chunk_in, chunk_in.length

        @stream[:next_in] = data_in
        @stream[:avail_in] = chunk_in.length

        begin
          data_out = MemoryPointer.new CHUNK

          @stream[:avail_out] = CHUNK
          @stream[:next_out] = data_out

          err = Zlib.deflate @stream_p, flush

          raise GzipFile::Error, "Zlib stream error" if err == Zlib::STREAM_ERROR

          have = CHUNK - @stream[:avail_out]

          chunk_out = data_out.read_string have

          buffer << chunk_out
        end while @stream[:avail_out] == 0
      end

      Zlib.deflateEnd @stream_p

      buffer
    end

  end

  class GzipFile
    class Error < Zlib::Error; end
  end

  class GzipReader < GzipFile # HACK usa a buffer class

    def initialize(io)
      @io = io
      window_bits = Zlib::MAX_WBITS + 16 # gzip header

      @inflator = Zlib::Inflate.new window_bits
    end

    def close
    end

    def finish
      true
    end

    def read
      data = ''

      while chunk = @io.read(CHUNK) do
        data << @inflator.inflate(chunk)
      end

      data
    end

  end

  class GzipWriter < GzipFile # HACK use a buffer class

    def initialize(io, level = Zlib::DEFAULT_COMPRESSION,
                   strategy = Zlib::DEFAULT_STRATEGY)
      @io = io
      window_bits = Zlib::MAX_WBITS + 16 # gzip header

      @deflator = Zlib::Deflate.new level, window_bits, nil, strategy

      @buffer = ''
    end

    def close
      finish
      @io.close
      nil
    end

    def finish
      until @buffer.empty? do
        chunk = @buffer.slice! 0, CHUNK
        @io.write @deflator.deflate(chunk)
      end
    end

    def flush
      true
    end

    def write(data)
      @buffer << data
      data.length
    end

  end

  class Inflate

    def self.inflate(data)
      new.inflate data
    end

    def initialize(window_bits = Zlib::MAX_WBITS)
      @window_bits = window_bits

      @stream_p = Zlib.z_stream_Alloc
      @stream = Zlib::Stream.new @stream_p

      err = Zlib.inflateInit2 @stream_p, @window_bits

      raise GzipFile::Error, "Zlib error #{err}" unless err == Zlib::OK # HACK
    end

    def inflate(data)
      err = nil
      data_in = MemoryPointer.new CHUNK
      data_out = MemoryPointer.new CHUNK

      data = data.dup
      buffer = ''

      begin
        chunk_in = data.slice! 0, CHUNK

        break if chunk_in.length == 0

        data_in.write_string chunk_in, chunk_in.length

        @stream[:avail_in] = chunk_in.length
        @stream[:next_in] = data_in

        begin
          @stream[:avail_out] = CHUNK
          @stream[:next_out] = data_out

          err = Zlib.inflate @stream_p, Zlib::NO_FLUSH

          case err
          when Zlib::STREAM_ERROR then
            raise GzipFile::Error, "Zlib stream error"
          when Zlib::NEED_DICT then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib data error, need dictionary"
          when Zlib::DATA_ERROR then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib data error: #{@stream[:msg]}"
          when Zlib::MEM_ERROR then
            Zlib.inflateEnd @stream_p
            raise GzipFile::Error, "Zlib memory error"
          end

          have = CHUNK - @stream[:avail_out]

          chunk_out = data_out.read_string have

          buffer << chunk_out
        end while @stream[:avail_out] == 0

      end until err == Zlib::STREAM_END

      Zlib.inflateEnd @stream_p

      raise GzipFile::Error, "Zlib data error" if err == Zlib::DATA_ERROR

      buffer
    ensure
      data_in.free
      data_out.free
    end

  end

end

